module carry_lookahead_adder
(
    input   logic[15:0]     A,
    input   logic[15:0]     B,
    output  logic[15:0]     Sum,
    output  logic           CO
);

    /* Code for Carry Lookahead Adder */
      logic [3:0] C;
      logic [3:0] G, P;

      always_comb begin
        for(int i = 0 ; i<4; i=i+1) begin
          C[i] = G[i] | (P[i] & C[i]);  // Based on the equation given in lab manual 4.4
        end
        C0 = C[3];
      end

      four_bit_ra FRA0(.x(A[3:0]), .y(B[3:0]), .cin(0), .g(G[0]), .p(P[0]));
      four_bit_ra FRA1(.x(A[7:4]), .y(B[7:4]), .cin(C[0]), .g(G[1]), .p(P[1]));
      four_bit_ra FRA2(.x(A[11:8]), .y(B[11:8]), .cin(C[1]), .g(G[2]), .p(P[2]));
      four_bit_ra FRA3(.x(A[15:12]), .y(B[15:12]), .cin(C[2]), .g(G[3]), .p(P[3]));


endmodule


module four_bit_ra(
                       input [3:0] x,
                       input [3:0] y,
                       input cin,
                       output logic [3:0] s,
                       //output logic cout
                       output logic g, p
                       );

  logic [3:0] C;
  logic [3:0] G, P;

  always_comb begin
    for(int i = 0 ; i<4; i=i+1) begin
      C[i] = G[i] | (P[i] & C[i]);  // Based on the equation given in lab manual 4.4
    end
    p = P[3];
    g = G[3];
  end

         full_adder fa0(.x(x[0]), .y(y[0]), .cin(cin), .s(s[0]), .g(G[0]), .p(P[0]));
         full_adder fa1(.x(x[1]), .y(y[1]), .cin(C[0]), .s(s[1]), .g(G[1]), .p(P[1]));
         full_adder fa2(.x(x[2]), .y(y[2]), .cin(C[1]), .s(s[2]), .g(G[2]), .p(P[2]));
         full_adder fa3(.x(x[3]), .y(y[3]), .cin(C[2]), .s(s[3]), .g(G[3]), .p(P[3]));

endmodule

module full_adder(
                      input x,
                      input y,
                      input cin,
                      output logic s,
                      //output logic cout,
                      output logic g, p
                     );
   assign s = x ^ y ^ cin;
   //assign cout = (x&y) | (y&cin) | (cin&x);
   assign g = x & y;
   assgin p = x ^ y;
endmodule
